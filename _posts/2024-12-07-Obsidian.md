---
layout: blog
title: Obsidian
section: Blog
last_modified_at: 2024-12-07
categories:
  - Productivity
---

# asdfas

<!--more-->

```javascript
const this_page = dv.current()
const year_int = (new Date()).getFullYear()
const year_str = `${year_int}`
const people = this_page.People


function parse_when_statement(when_str) {
	const re_date_format = new RegExp(/\d{4}-\d{2}-\d{2}/)
	const when_block_strs = when_str.toLowerCase().split(" - ")
	const when_blocks = when_str
		.split(" - ")
		.filter(s=>s!=="winter")
		.map(parse_when_block)
	const winter_idx = when_block_strs.indexOf("winter")

	const winter_block_a = parse_when_block("early winter")
	const winter_block_b = parse_when_block("mid winter")
	const winter_block_c = parse_when_block("late winter")	

	//const when_blocks = when_str.split(" - ").map(parse_when_block)	
	if (when_blocks.length==0 && winter_idx==0) { 
		// only winter
		return [
			{start: winter_block_a.start, end: winter_block_a.end},
			{start: winter_block_b.start, end: winter_block_c.end}
		]
	} else if (when_blocks.length==1 && winter_idx < 0) { 
		// no winter, only one other thing
		if (re_date_format.test(when_blocks[0])) {
			return [{milestone: when_blocks[0]}]
		} else {
			return [when_blocks[0]]
		}
	} else if (when_blocks.length==1 && winter_idx >= 0) { 
		// mix of winter and something else
		if (winter_idx == 0) {
			// winter was first, other must be after winter
			return [
				{start:winter_block_a.start, end:winter_block_a.end},
				{start:winter_block_b.start, end:when_blocks[0].end}
			]
		} else if (winter_idx==1) {
			// winter was second, other must be before winter
			return [
				{start:when_blocks[0].start, end:winter_block_a.end},
				{start:winter_block_b.start, end:winter_block_c.end}
			]
		}
	} else if (when_blocks.length==2) { 
		// winter not present in origional
		return [{start:when_blocks[0].start, end:when_blocks[1].end}]
	} else {
		throw EvalError(`Too many values found in this "When" statement: ${when_str}`)
	}
}
function parse_when_block(when_str) {
	const re_str_approx_format = "(?:((?:late)|(?:early)|(?:mid)) )?"
	const re_str_season_format = "((?:spring)|(?:summer)|(?:fall)|(?:winter))"
	const re_str_month_format = "((?:(?:(?:jan)|(?:feb))(?:uary)?)|(?:(?:mar)(?:ch)?)|(?:(?:apr)(?:il)?)|(?:may)|(?:(?:jun)e?)|(?:(?:jul)y?)|(?:(?:(?:aug)(?:ust)?)|(?:(?:sept?(?:em)?)|(?:octo?)|(?:nov(?:em)?)|(?:dec(?:em)?))(?:ber)?))"
	const re_date_format = new RegExp(/\d{4}-\d{2}-\d{2}/)
	const re_season_format = new RegExp(re_str_approx_format+re_str_season_format, "i")
	const re_month_format = new RegExp(re_str_approx_format+re_str_month_format, "i")
		
	const season_map = {
		spring: ["mar", "apr", "may"],
		summer: ["jun", "jul", "aug"],
		fall: ["sep", "oct", "nov"],
		winter: ["dec", "jan", "feb"]
	}
	const month_map = {
		//  month#,  last day
		jan: ["01", "31"],
		feb: ["02", "28"],
		mar: ["03", "31"],
		apr: ["04", "30"],
		may: ["05", "31"],
		jun: ["06", "30"],
		jul: ["07", "31"],
		aug: ["08", "31"],
		sep: ["09", "30"],
		oct: ["10", "31"],
		nov: ["11", "30"],
		dec: ["12", "31"]
	}
	function parse_season_format(when_str) {
		const [,approx,season] = when_str.toLowerCase().match(re_season_format)
		const approx_map = {
			"early": [season_map[season][0], season_map[season][0]],
			"mid": [season_map[season][1], season_map[season][1]],
			"late": [season_map[season][2], season_map[season][2]],
			undefined: [season_map[season][0], season_map[season][2]]
		}
		const mnths = approx_map[approx]
		return {
			start: `${year_str}-${month_map[mnths[0]][0]}-01`, 
			end: `${year_str}-${month_map[mnths[1]][0]}-${month_map[mnths[1]][1]}`
		}
	}
	function parse_month_format(when_str) {
		let [,approx,mnth] = when_str.toLowerCase().match(re_month_format)
		mnth = mnth.slice(0,3)
		const date_map = {
			early: ["01","10"],
			mid: ["10","20"],
			late: ["20",month_map[mnth][1]],
			undefined: ["01",month_map[mnth][1]]
		}
		const dates = date_map[approx]
		return {
			start: `${year_str}-${month_map[mnth][0]}-${dates[0]}`,
			end: `${year_str}-${month_map[mnth][0]}-${dates[1]}`
		}
	}
	const is_season_format = re_season_format.test(when_str)
	const is_month_format = re_month_format.test(when_str)
	const is_date_format = re_date_format.test(when_str)

	if (is_season_format) {
		return parse_season_format(when_str)
	} else if (is_month_format) {
		return parse_month_format(when_str)
	} else if (is_date_format) {
		return when_str
	}
	
	//let when_blocks = when_str.split(", ")
	//when_blocks = when_blocks.map(b => b.split(" - "))
}
function handle_metadata_entry(meta_obj) {
	//console.log(meta_obj)
	const metadata_keys = [
		"Assigned",
		"Limit to",
		"Type",
		"Critical",
		"Completed",
		"When"
	]
	const re_metadata = new RegExp(`\\*{0,2}((?:${metadata_keys.join(")|(?:")}))\\*{0,2}(?:: ?(.+))?`)
	const re_year = /(\d{4})/g

	const match = meta_obj.text.match(re_metadata)
	const metadata_type = match?`${match[1].slice(0,1).toUpperCase()}${match[1].slice(1).toLowerCase()}`:null
	let metadata = {}
	if (match !== null) {
		if (metadata_type === "Critical") {
			metadata[metadata_type] = true
		} else if (metadata_type === "Completed") {
			metadata[metadata_type] = match[2].split(", ").map(v=>["1", "y"].includes(v.toLowerCase()))
		} else if (metadata_type === "When") {
			metadata.Tasks = meta_obj.subtasks.filter(t => t.task).map(t=>{return{Dates: parse_when_statement(t.text), Is_Complete: t.completed}})
			metadata[metadata_type] = match[2]
		} else {
			metadata[metadata_type] = match[2]
		}
	}
	return metadata
}
function wrap_str(s_to_wrap, target_line_length) {
	const space_idxs = [...s_to_wrap.matchAll(/ /g)].map(o=>o.index) 
  const min_idx = space_idxs.findIndex(idx=>idx+1>=(target_line_length))
  if (space_idxs[min_idx]>0){
  	const str_first_part = s_to_wrap.slice(0,space_idxs[min_idx])
    let str_second_part = s_to_wrap.slice(space_idxs[min_idx])
    if (str_second_part.match(new RegExp(`.{${target_line_length}}.*( )`))) {
    	str_second_part = wrap_str(str_second_part, target_line_length)
    }
  	return `${str_first_part}<br>${str_second_part}`
  } else {
  	return s_to_wrap
  }
}


let events = {}
for (
	let e of 
	Array.prototype.concat(
		this_page.file.lists.values,
		this_page.file.tasks.values
	)
) {
	if (e.section.type == "header") {
		const event_name = e.section.subpath.replace("'", "’")
		if (events[event_name] === undefined) events[event_name] = {}
		Object.assign(events[event_name], handle_metadata_entry(e))
	}
}

let gantt_lines = []
for (const [job_title, job_info] of Object.entries(events)) {
	//console.log(job_title, job_info)
	//gantt_lines.push(`    section ${job_title.replaceAll(" ","<br>")}`)
	gantt_lines.push(`    section ${wrap_str(job_title,8)}`)
	for (const task of job_info.Tasks) {
		//console.log(task)
		task.Dates.forEach((date, idx)=>{
		  //$
			if (date.milestone) {
				gantt_lines.push(`        ${task.Is_Complete?"🗸":"🗶"+people[job_info.Assigned]}${task.Dates.length>1?idx==0?"⤝":"⤞":""} : ${job_info.Critical?"crit, ":""}${task.Is_Complete?"done, ":""} milestone, ${date.milestone}, 0d`)
			} else {
				gantt_lines.push(`        ${task.Dates.length>1&&idx==1?"⤝":""}${task.Is_Complete?"🗸":"🗶"+people[job_info.Assigned]}${task.Dates.length>1&&idx==0?"⤞":""} : ${job_info.Critical?"crit, ":""}${task.Is_Complete?"done, ":""} ${date.start}, ${date.end}`)
			}
			
		})
		//for (const date of task.Dates) {
			
		//}
	}
}

const mermaidConf = `mermaid
--- 
barHeight: 35
rightPadding: 0
leftPadding: 120
gridLineStartPadding: 20
tickInterval: '1 month'
displayMode: compact

---
gantt
    title ${this_page.file.name}
    dateFormat  YYYY-MM-DD
    axisFormat  %b
    todayMarker on
`
const year_span = `    Year start to end : active, done, ${year_str}-01-01, 365d\n`
const backticks = "```"

const gantt_str = `${backticks}${mermaidConf}${year_span}${gantt_lines.join("\n")}\n${backticks}`
console.log(gantt_str)

// Gantt chart
dv.paragraph(gantt_str,)
```